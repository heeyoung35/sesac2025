<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">

        const { useState, useEffect } = React;

        function Counter() {
            const [count, setCount] = useState(0);
            const [otherState, setOtherState] = useState(0);

            // 1. 의존성 배열 생략: 매 렌더링마다 실행(사용이 적음)
            // 하지만 document는 실제 dom에 접근해 버린다. 리엑트를 사용하는 이유는 가상돔을 사용하기 위함이다.
            // 두 번째 실행하게 된다. 마운트가 되고 마운트에서 실행될 것을 useEffect에 담아서 실행된다.
             useEffect(() => {
                //  렌더링이 완료된 후 실행                                       
                console.log('렌더링될 때마다 실행')
                document.title = `너는 ${count}번 클릭했어!!`;
             });
             // 2. 빈 의존성 배열 []: 첫 렌더링Mount시에만 실행
             // 주로 초기 데이터 로딩API호출 등에 사용된다.
            useEffect(() => {
                console.log('컴포넌트가 처음 화면에 나타남(Mount)');
            }, []);    // []빈 배열을 넣어주면 처음 한번에 실행된다. 의존성 배열
            // 맨 처음 서버에서 데이터를 받아올 때 사용된다. 
            
            // 3. 의존성 배열에 특정 값 지정[count] : 해당 값이 변경될 때마다 실행
            // 가장 일반적인 사용법이ek. 불펼요한 재실행을 막아 성능을 최적화한다.
            useEffect(() => {
                console.log(`'count값이 ${count}로 변경되어, 이 useEffect가 실행됩니다.'`)
            }, [count]); // 외존성 배열에 count값을 넣어주었기 때문에 count가 변경될 때만 useEffect가 실행된다.
            
            console.log('Counter 컴포넌트가 렌더링 되었습니다.'); // 가장 먼저 화면으로 그려준다.
            
            // 리엑트는 리턴된 내용만이 할일이다. 
            return (
                <>
                    <h2>단순 카운터</h2>
                    <p>{count}번 클릭했습니다.</p>
                    <button onClick={ () => setCount(count +1)}>클릭</button>
                    <p>other Count: {otherState}</p>
                    <button onClick={ () => setOtherState(otherState +1)}>클릭</button>
                </>
            )
        }

        function Timer() {

            useEffect(() => {
                console.log('타이머가 시작되었습니다.(Mount시점)');

                const timerId = setInterval(() => {
                    console.log('...1초 경과....');
                }, 1000);

                // Cleanup 함수: useEffect가 반환하는 함수이다.
                // 이 함수는 컴포넌트가 화면에서 사라지기 직전(Unmoint)에 호출된다.
                return () => {
                    console.log('타이머를 정리합니다.(Unmount)');
                    clearInterval(timerId); // 생성했던 타이머 제거
                }
            }, []);

            return (
                <h3>타이머가 동작중입니다. (콘솔을 확인하세요~)</h3>
            )
        }

        function App() {
            const [showTimer, setShowTimer ] = useState(true);

            return (
                <>
                    <Counter/>
                    <hr/>
                    <button onClick={() => setShowTimer(!showTimer)}>
                        타이머 보이기/숨기기
                    </button>
                    {/*showTimer가 true일 때만 Timer 컴포넌트가 렌더링 된다. &&연산자는 뒤에도 true일 때 true값이 반환*/}
                    {showTimer && <Timer/>}  
                </>
            );
        }


        ReactDOM.createRoot(document.getElementById('root')).render(<App/>);

    </script>
</body>
</html>